import gradio as gr
from transformers import AutoTokenizer, AutoModelForSeq2SeqLM, pipeline
from collections import Counter
import torch
from nltk.corpus import wordnet
import nltk
nltk.download('wordnet')

# Ladataan BART-tokenisoija ja malli tiivistelmien tekemiseen
tokenizer = AutoTokenizer.from_pretrained("facebook/bart-large-cnn")
model = AutoModelForSeq2SeqLM.from_pretrained("facebook/bart-large-cnn")

# Tarkistetaan, onko GPU käytettävissä ja käytetään sitä, jos mahdollista
device = "cuda" if torch.cuda.is_available() else "cpu"
model = model.to(device)

# Funktio tärkeimpien kohtien tiivistämiseen
def extract_main_points(text, num_points=5):
    summary = summarize_bart(text, max_length=150, min_length=80)
    sentences = summary.split('. ')
    points = [f"• {sentence.strip()}." for sentence in sentences[:num_points] if sentence.strip()]
    return "\n".join(points)

# Funktio tärkeiden substantiivien ja adjektiivien poimimiseen tekstistä
def extract_key_terms(text, num_concepts=10):
    words = nltk.word_tokenize(text)
    pos_tags = nltk.pos_tag(words)
    relevant_words = [word for word, pos in pos_tags if pos in ["NN", "JJ"] and len(word) > 3]
    most_common_words = [word for word, _ in Counter(relevant_words).most_common(num_concepts)]
    return most_common_words

# Funktio käsitteiden listaamiseen ja niiden määritelmien generoimiseen
def extract_concepts_with_definitions(text, num_concepts=10):
    key_terms = extract_key_terms(text, num_concepts)
    definitions = []
    
    for term in set(key_terms):
        # Yritetään saada määritelmä WordNetistä
        synsets = wordnet.synsets(term)
        if synsets:
            definition = synsets[0].definition()
            definitions.append(f"• {term} = {definition.strip()}")
        else:
            # Sanakirjamääritelmää ei löytynyt, ei lisätä määritelmää
            continue

    # Jos määritelmiä ei ole, palautetaan tyhjää
    if not definitions:
        return "Ei määritelmiä löytynyt."

    return "\n".join(definitions)

# Funktio tiivistämään teksti BART-mallilla
def summarize_bart(input_text, max_length, min_length):
    inputs = tokenizer(input_text, return_tensors="pt", max_length=1024, truncation=True)
    inputs = inputs.to(device)
    summary_ids = model.generate(inputs["input_ids"], max_length=max_length, min_length=min_length, do_sample=False)
    summary = tokenizer.decode(summary_ids[0], skip_special_tokens=True)
    return summary

# Funktio tiivistelmän luomiseen valitun tiivistelmätyypin perusteella
def generate_summary(input_text, url, file, format_type, source):
    if source == "Text Input":
        content = input_text
    elif source == "Web Page URL":
        content = url
    elif source == "File Upload" and file is not None:
        content = file.read().decode('utf-8')
    else:
        content = ""

    if not content:
        return "Ei sisältöä tiivistettäväksi."

    try:
        if format_type == "Main Points":
            summary = extract_main_points(content)
        elif format_type == "Concepts List":
            summary = extract_concepts_with_definitions(content)
        elif format_type == "Short Summary":
            summary = summarize_bart(content, max_length=80, min_length=40)
        elif format_type == "Medium Summary":
            summary = summarize_bart(content, max_length=200, min_length=100)
        elif format_type == "Long Summary":
            summary = summarize_bart(content, max_length=400, min_length=200)
        else:
            summary = content
    except Exception as e:
        return f"Virhe tiivistämisen aikana: {str(e)}"

    return summary

# Funktio dynaamiseen syöttökentän näkyvyyden hallintaan
def dynamic_input(source):
    if source == "Text Input":
        return gr.update(visible=True), gr.update(visible=False), gr.update(visible=False)
    elif source == "Web Page URL":
        return gr.update(visible=True), gr.update(visible=False), gr.update(visible=False)
    elif source == "File Upload":
        return gr.update(visible=False), gr.update(visible=True), gr.update(visible=False)
    return gr.update(visible=False), gr.update(visible=False), gr.update(visible=False)

# Gradio-käyttöliittymän rakentaminen
with gr.Blocks() as demo:
    gr.Markdown("### Summary App")

    # Syöttötavan valinta
    source = gr.Dropdown(["Text Input", "Web Page URL", "File Upload"], label="Input type", value="Text Input", interactive=True)

    # Syöttökentät
    text_input_box = gr.Textbox(label="Enter Text", visible=True)
    file_input_box = gr.File(label="Upload a File", visible=False)
    url_input_box = gr.Textbox(label="Give Website URL", visible=False)

    # Tiivistelmätyypin valinta
    format_type = gr.Dropdown(
        ["Main Points", "Concepts List", "Short Summary", "Medium Summary", "Long Summary"],
        label="Choose Summary Type",
        value="Main Points"
    )

    # Generoidun tiivistelmän näyttökenttä
    summary_output_box = gr.Textbox(label="Generate Summary", visible=True, lines=10)

    # Painike tiivistämisen käynnistämiseksi
    summary_button = gr.Button("Generate Summary")

    # Alustetaan tiivistelmän luominen
    summary_button.click(
        fn=generate_summary,
        inputs=[text_input_box, url_input_box, file_input_box, format_type, source],
        outputs=[summary_output_box]
    )

    # Syöttökenttien dynaaminen näkyvyys syöttötavan perusteella
    source.change(fn=dynamic_input, inputs=source, outputs=[text_input_box, file_input_box, url_input_box])

# Käyttöliittymän käynnistys
demo.launch()
